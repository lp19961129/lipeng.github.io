<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React性能优化全面指南 - 个人博客</title>
    <!-- 引入外部资源 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- 引入自定义样式 -->
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .blog-post-detail {
            padding: 60px 0;
        }
        .blog-post-detail .container {
            max-width: 800px;
        }
        .post-header {
            margin-bottom: 40px;
        }
        .post-cover {
            margin-bottom: 30px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .post-cover img {
            width: 100%;
            height: auto;
            display: block;
        }
        .post-meta {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            color: var(--text-secondary);
            font-size: 14px;
        }
        .post-meta span {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .post-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        .post-content {
            line-height: 1.8;
            margin-bottom: 40px;
        }
        .post-content h2 {
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.8rem;
        }
        .post-content h3 {
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        .post-content p {
            margin-bottom: 20px;
        }
        .post-content ul,
        .post-content ol {
            margin-bottom: 20px;
            padding-left: 25px;
        }
        .post-content li {
            margin-bottom: 10px;
        }
        .post-content code {
            background-color: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }
        .post-content pre {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
        }
        .post-content pre code {
            background-color: transparent;
            padding: 0;
        }
        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 40px;
        }
        .post-tags .tag {
            background-color: var(--light-bg);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.3s ease;
        }
        .post-tags .tag:hover {
            background-color: var(--primary-color);
            color: white;
        }
        .related-posts {
            margin-top: 60px;
            padding-top: 40px;
            border-top: 1px solid var(--border-color);
        }
        .related-posts h3 {
            margin-bottom: 30px;
            font-size: 1.8rem;
        }
        .related-posts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 30px;
        }
        .related-post {
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .related-post:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }
        .related-post-image {
            height: 160px;
            overflow: hidden;
        }
        .related-post-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease;
        }
        .related-post:hover .related-post-image img {
            transform: scale(1.05);
        }
        .related-post-content {
            padding: 20px;
        }
        .related-post-date {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        .related-post-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        .related-post-title a {
            color: var(--text-primary);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        .related-post-title a:hover {
            color: var(--primary-color);
        }
        .comment-section {
            margin-top: 60px;
            padding-top: 40px;
            border-top: 1px solid var(--border-color);
        }
        .comment-section h3 {
            margin-bottom: 30px;
            font-size: 1.8rem;
        }
        .comment-form {
            margin-bottom: 40px;
        }
        .comment-form .form-group {
            margin-bottom: 20px;
        }
        .comment-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .comment-form input,
        .comment-form textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        .comment-form input:focus,
        .comment-form textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        .comment-form textarea {
            min-height: 150px;
            resize: vertical;
        }
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid var(--border-color);
        }
        .post-nav-link {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .post-nav-link:hover {
            color: var(--primary-color);
        }
        .post-nav-link i {
            font-size: 1.2rem;
        }
        .post-nav-link.previous {
            flex-direction: row-reverse;
        }
        .performance-tip {
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }
        .common-mistake {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }
        .code-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .code-comparison .before,
        .code-comparison .after {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            position: relative;
        }
        .code-comparison .before::before,
        .code-comparison .after::before {
            position: absolute;
            top: -10px;
            left: 10px;
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .code-comparison .before::before {
            content: "优化前";
            background-color: #dc3545;
            color: white;
        }
        .code-comparison .after::before {
            content: "优化后";
            background-color: #28a745;
            color: white;
        }
        .optimization-level {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }
        .level-basic {
            background-color: #d4edda;
            color: #155724;
        }
        .level-intermediate {
            background-color: #fff3cd;
            color: #856404;
        }
        .level-advanced {
            background-color: #f8d7da;
            color: #721c24;
        }
        .component-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .component-box {
            padding: 15px 30px;
            margin: 10px 0;
            background-color: #e9ecef;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .component-connector {
            width: 2px;
            height: 30px;
            background-color: #6c757d;
        }
        @media (max-width: 768px) {
            .code-comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <header class="navbar" id="navbar">
        <div class="container">
            <div class="logo">
                <a href="../index.html">
                    <i class="fas fa-leaf"></i> 个人博客
                </a>
            </div>
            <nav class="nav-links">
                <ul>
                    <li><a href="../index.html">首页</a></li>
                    <li><a href="../index.html#about">关于我</a></li>
                    <li><a href="../index.html#blog" class="active">博客</a></li>
                    <li><a href="../index.html#contact">联系</a></li>
                </ul>
            </nav>
            <div class="mobile-menu">
                <button class="menu-toggle" id="menu-toggle">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 博客文章详情 -->
    <section class="blog-post-detail">
        <div class="container">
            <article>
                <!-- 文章头部 -->
                <div class="post-header">
                    <div class="post-cover">
                        <img src="../images/blog5.svg" alt="React性能优化全面指南">
                    </div>
                    <div class="post-meta">
                        <span><i class="far fa-calendar-alt"></i> 2023-09-20</span>
                        <span><i class="far fa-folder"></i> React开发</span>
                        <span><i class="far fa-eye"></i> 阅读量: 1452</span>
                    </div>
                    <h1 class="post-title">React性能优化全面指南</h1>
                </div>

                <!-- 文章内容 -->
                <div class="post-content">
                    <p>React是一个用于构建用户界面的JavaScript库，它通过虚拟DOM和高效的渲染算法提供了良好的性能。然而，随着应用规模的增长和复杂度的提高，性能问题可能会逐渐显现。本文将详细介绍React应用性能优化的各个方面，从基础的渲染优化到高级的状态管理策略，帮助你构建高性能的React应用。</p>

                    <div class="performance-tip">
                        <strong>性能优化原则：</strong>性能优化的首要原则是"测量，然后优化"。在开始优化之前，使用React DevTools Profiler或浏览器性能工具确定性能瓶颈所在，避免盲目优化和过早优化。
                    </div>

                    <h2>一、理解React渲染机制</h2>
                    
                    <p>在进行性能优化之前，我们需要先了解React的渲染机制，包括虚拟DOM、调和算法以及组件更新过程。</p>

                    <h3>1. 虚拟DOM与调和算法</h3>
                    <p>React使用虚拟DOM（Virtual DOM）来减少对真实DOM的操作。当组件状态或属性变化时，React会：</p>
                    <ol>
                        <li>创建新的虚拟DOM树</li>
                        <li>通过调和算法（Reconciliation）比较新旧虚拟DOM树的差异</li>
                        <li>只将变化的部分应用到真实DOM</li>
                    </ol>

                    <div class="component-diagram">
                        <div class="component-box">组件状态/属性变化</div>
                        <div class="component-connector"></div>
                        <div class="component-box">创建新的虚拟DOM树</div>
                        <div class="component-connector"></div>
                        <div class="component-box">调和算法（Diffing）</div>
                        <div class="component-connector"></div>
                        <div class="component-box">更新真实DOM</div>
                    </div>

                    <h3>2. 组件更新生命周期</h3>
                    <p>在类组件中，组件更新的主要生命周期方法包括：</p>
                    <ul>
                        <li><code>shouldComponentUpdate</code></li>
                        <li><code>componentWillUpdate</code>（已废弃）</li>
                        <li><code>render</code></li>
                        <li><code>componentDidUpdate</code></li>
                    </ul>
                    
                    <p>在函数组件中，更新过程由React内部管理，我们可以通过React Hooks来控制渲染行为。</p>

                    <h2>二、基础性能优化技术</h2>

                    <h3>1. 使用React.memo避免不必要的重新渲染 <span class="optimization-level level-basic">基础</span></h3>
                    <p><code>React.memo</code>是一个高阶组件，它可以缓存函数组件的渲染结果，只有当组件的props发生变化时才重新渲染。</p>

                    <div class="code-comparison">
                        <div class="before">
                            <pre><code>// 每次父组件渲染时，这个组件都会重新渲染
function UserProfile({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}</code></pre>
                        </div>
                        <div class="after">
                            <pre><code>// 只有当user属性变化时才会重新渲染
const UserProfile = React.memo(({ user }) => {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
});</code></pre>
                        </div>
                    </div>

                    <div class="performance-tip">
                        <strong>注意：</strong><code>React.memo</code>默认只进行浅比较（shallow comparison）。如果props包含复杂对象，需要提供自定义的比较函数。
                    </div>

                    <h4>自定义比较函数</h4>
                    <pre><code>const UserProfile = React.memo(({ user }) => {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}, (prevProps, nextProps) => {
  // 如果返回true，则组件不会重新渲染
  return prevProps.user.id === nextProps.user.id && 
         prevProps.user.name === nextProps.user.name &&
         prevProps.user.email === nextProps.user.email;
});</code></pre>

                    <h3>2. 合理使用useState和useReducer <span class="optimization-level level-basic">基础</span></h3>
                    <p>状态管理是React应用性能的关键因素。合理设计状态结构可以避免不必要的重新渲染。</p>

                    <h4>将不相关的状态分离</h4>
                    <div class="code-comparison">
                        <div class="before">
                            <pre><code>function UserDashboard() {
  const [userData, setUserData] = useState({
    profile: { name: '', email: '' },
    posts: [],
    notifications: []
  });
  
  // 更新notifications会导致整个userData对象变化
  // 触发组件重新渲染
  const updateNotifications = (newNotifications) => {
    setUserData(prev => ({
      ...prev,
      notifications: newNotifications
    }));
  };
}</code></pre>
                        </div>
                        <div class="after">
                            <pre><code>function UserDashboard() {
  // 分离状态，避免相互影响
  const [profile, setProfile] = useState({ name: '', email: '' });
  const [posts, setPosts] = useState([]);
  const [notifications, setNotifications] = useState([]);
  
  // 只更新notifications，不会影响其他状态
  // 减少不必要的重新渲染
}</code></pre>
                        </div>
                    </div>

                    <h4>使用useReducer管理复杂状态</h4>
                    <p>当状态逻辑复杂或状态更新依赖于之前的状态时，使用<code>useReducer</code>可以使代码更清晰、更可预测。</p>
                    <pre><code>function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}</code></pre>

                    <h3>3. 避免在render中创建函数 <span class="optimization-level level-basic">基础</span></h3>
                    <p>每次渲染时创建新的函数实例会导致子组件不必要的重新渲染，尤其是当这些函数作为props传递给使用<code>React.memo</code>的组件时。</p>

                    <div class="code-comparison">
                        <div class="before">
                            <pre><code>function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // 每次渲染都会创建新的handleClick函数
  const handleClick = () => {
    setCount(count + 1);
  };
  
  return (
    <div>
      <Counter count={count} onClick={handleClick} />
    </div>
  );
}</code></pre>
                        </div>
                        <div class="after">
                            <pre><code>function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // 使用useCallback缓存函数
  const handleClick = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []); // 空依赖数组表示函数不会更新
  
  return (
    <div>
      <Counter count={count} onClick={handleClick} />
    </div>
  );
}</code></pre>
                        </div>
                    </div>

                    <h3>4. 使用useMemo缓存计算结果 <span class="optimization-level level-basic">基础</span></h3>
                    <p>对于昂贵的计算，使用<code>useMemo</code>可以缓存计算结果，避免在每次渲染时都重新计算。</p>

                    <pre><code>function ExpensiveComponent({ items, filter }) {
  // 使用useMemo缓存过滤结果
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item => item.status === filter);
  }, [items, filter]); // 依赖于items和filter
  
  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}</code></pre>

                    <div class="common-mistake">
                        <strong>常见错误：</strong>不要过度使用<code>useMemo</code>和<code>useCallback</code>。缓存也有成本，对于简单的计算或小型组件，缓存可能会导致更多的内存使用而不会带来显著的性能提升。
                    </div>

                    <h3>5. 使用key优化列表渲染 <span class="optimization-level level-basic">基础</span></h3>
                    <p>在渲染列表时，为每个项目提供唯一且稳定的<code>key</code>属性可以帮助React识别哪些项目被添加、删除或重新排序，从而避免不必要的DOM操作。</p>

                    <div class="code-comparison">
                        <div class="before">
                            <pre><code>// 避免使用索引作为key
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}>{todo.text}</li>
      ))}
    </ul>
  );
}</code></pre>
                        </div>
                        <div class="after">
                            <pre><code>// 使用唯一标识符作为key
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}</code></pre>
                        </div>
                    </div>

                    <div class="performance-tip">
                        <strong>最佳实践：</strong>使用稳定的、唯一的标识符作为key。理想情况下，这应该是数据本身的一部分，如数据库ID。避免使用随机生成的值作为key，因为这会导致每次渲染时都重新创建DOM元素。
                    </div>

                    <h2>三、中级性能优化技术</h2>

                    <h3>1. 虚拟滚动（Virtual Scrolling） <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>当渲染大量数据（如长列表）时，虚拟滚动是一种强大的优化技术。它只渲染当前可见区域内的项目，而不是整个列表。</p>

                    <h4>使用第三方库实现虚拟滚动</h4>
                    <p>可以使用如<code>react-window</code>或<code>react-virtualized</code>这样的库来实现虚拟滚动：</p>

                    <pre><code>import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );
  
  return (
    <FixedSizeList
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}</code></pre>

                    <h3>2. 代码分割与懒加载 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>代码分割可以减小初始加载的包大小，提高应用的初始加载速度。React提供了<code>React.lazy</code>和<code>Suspense</code>来实现组件的懒加载。</p>

                    <h4>基本用法</h4>
                    <pre><code>// 使用React.lazy懒加载组件
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}</code></pre>

                    <h4>基于路由的代码分割</h4>
                    <p>在使用React Router时，可以基于路由进行代码分割：</p>
                    <pre><code>import { BrowserRouter as Router, Routes, Route, Suspense } from 'react-router-dom';

// 懒加载路由组件
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));
const Dashboard = React.lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </Router>
  );
}</code></pre>

                    <h3>3. 使用Context优化状态管理 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>Context API是React内置的状态管理解决方案，但不当使用可能导致性能问题。以下是一些优化Context使用的技巧：</p>

                    <h4>分离多个独立的Context</h4>
                    <p>将相关的状态分离到不同的Context中，避免一个Context的变化导致所有消费者重新渲染：</p>

                    <pre><code>// 分离的Context
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

// 提供者组件
function AppProviders({ children }) {
  // 用户状态
  const [user, setUser] = useState(null);
  
  // 主题状态
  const [theme, setTheme] = useState('light');
  
  // 通知状态
  const [notifications, setNotifications] = useState([]);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <NotificationContext.Provider value={{ notifications, setNotifications }}>
          {children}
        </NotificationContext.Provider>
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}</code></pre>

                    <h4>使用useMemo优化Context值</h4>
                    <p>使用<code>useMemo</code>缓存Context的值，避免不必要的Context更新：</p>

                    <pre><code>function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [accentColor, setAccentColor] = useState('#007bff');
  
  // 使用useMemo缓存Context值
  const contextValue = useMemo(() => ({
    theme,
    setTheme,
    accentColor,
    setAccentColor
  }), [theme, accentColor]); // 只在theme或accentColor变化时更新
  
  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
}</code></pre>

                    <h3>4. 优化大型组件树 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>对于大型组件树，可以采取以下策略来优化性能：</p>

                    <h4>组件拆分</h4>
                    <p>将大型组件拆分为更小、更专注的组件，这样可以使渲染更有针对性，只有发生变化的部分才会重新渲染：</p>

                    <pre><code>// 大型组件拆分示例
function LargeComponent() {
  const [userData, setUserData] = useState({ name: '', email: '' });
  const [posts, setPosts] = useState([]);
  const [comments, setComments] = useState([]);
  
  return (
    <div>
      {/* 将不同功能拆分为独立组件 */}
      <UserProfile user={userData} onUpdate={setUserData} />
      <PostsList posts={posts} onPostsChange={setPosts} />
      <CommentsList comments={comments} />
    </div>
  );
}</code></pre>

                    <h4>使用shouldComponentUpdate（类组件）</h4>
                    <p>对于类组件，可以使用<code>shouldComponentUpdate</code>方法来控制组件是否应该重新渲染：</p>

                    <pre><code>class UserProfile extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // 只有当用户ID变化时才重新渲染
    return this.props.user.id !== nextProps.user.id;
  }
  
  render() {
    const { user } = this.props;
    return (
      <div>
        <h2>{user.name}</h2>
        <p>{user.email}</p>
      </div>
    );
  }
}</code></pre>

                    <h3>5. 使用React.Fragment和React.memo组合 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>当需要返回多个元素但不想引入额外的DOM节点时，可以使用<code>React.Fragment</code>。将<code>React.Fragment</code>与<code>React.memo</code>结合使用可以优化渲染性能：</p>

                    <pre><code>const TableRow = React.memo(({ rowData }) => (
  <React.Fragment>
    <tr>
      <td>{rowData.id}</td>
      <td>{rowData.name}</td>
      <td>{rowData.value}</td>
    </tr>
    {rowData.hasDetails && (
      <tr>
        <td colSpan="3">{rowData.details}</td>
      </tr>
    )}
  </React.Fragment>
));</code></pre>

                    <h2>四、高级性能优化技术</h2>

                    <h3>1. 使用时间分片（Time Slicing） <span class="optimization-level level-advanced">高级</span></h3>
                    <p>时间分片是一种将长时间运行的任务分割成多个小任务的技术，这样可以避免阻塞主线程，使UI保持响应。</p>

                    <h4>使用requestIdleCallback</h4>
                    <pre><code>function processLargeData(data, chunkSize = 100) {
  let index = 0;
  
  function processChunk() {
    // 处理当前数据块
    const chunk = data.slice(index, index + chunkSize);
    
    for (let i = 0; i < chunk.length; i++) {
      // 处理单个项目
      processItem(chunk[i]);
    }
    
    index += chunkSize;
    
    // 如果还有数据要处理，在下一个空闲时间继续
    if (index < data.length) {
      requestIdleCallback(processChunk);
    } else {
      // 处理完成
      onProcessingComplete();
    }
  }
  
  // 开始处理第一个数据块
  requestIdleCallback(processChunk);
}</code></pre>

                    <h3>2. 避免不必要的重渲染级联 <span class="optimization-level level-advanced">高级</span></h3>
                    <p>在复杂的组件树中，一个组件的重渲染可能会触发整个子树的重渲染。以下是一些避免这种级联重渲染的技巧：</p>

                    <h4>组件解耦</h4>
                    <p>使用状态提升、Context或专门的状态管理库（如Redux）来解耦组件，避免组件之间的过度耦合：</p>

                    <pre><code>// 使用Context解耦组件
const DataContext = createContext();

function DataProvider({ children }) {
  const [data, setData] = useState([]);
  
  const fetchData = async () => {
    const response = await fetch('/api/data');
    const newData = await response.json();
    setData(newData);
  };
  
  // 只在需要时获取数据
  useEffect(() => {
    fetchData();
  }, []);
  
  return (
    <DataContext.Provider value={data}>
      {children}
    </DataContext.Provider>
  );
}

// 数据消费者组件
const DataConsumer = React.memo(() => {
  const data = useContext(DataContext);
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
});</code></pre>

                    <h4>使用React DevTools Profiler分析组件渲染</h4>
                    <p>使用React DevTools Profiler来识别导致级联重渲染的组件：</p>
                    <ol>
                        <li>安装React DevTools浏览器扩展</li>
                        <li>打开Profiler选项卡</li>
                        <li>点击录制按钮，执行可能导致性能问题的操作</li>
                        <li>查看火焰图，识别渲染时间长或不必要重渲染的组件</li>
                    </ol>

                    <h3>3. 自定义Hook与性能优化 <span class="optimization-level level-advanced">高级</span></h3>
                    <p>创建自定义Hook是一种重用状态逻辑的好方法，同时也可以用来优化性能。</p>

                    <h4>创建带缓存的API请求Hook</h4>
                    <pre><code>function useFetchWithCache(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // 使用useRef存储缓存
  const cache = useRef(new Map());
  
  useEffect(() => {
    // 检查缓存
    if (cache.current.has(url)) {
      setData(cache.current.get(url));
      setLoading(false);
      return;
    }
    
    // 缓存未命中，发送请求
    setLoading(true);
    
    fetch(url, options)
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        // 存储到缓存
        cache.current.set(url, data);
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [url, JSON.stringify(options)]); // 注意这里对options进行了序列化
  
  // 添加清除缓存的方法
  const invalidateCache = () => {
    cache.current.delete(url);
  };
  
  return { data, loading, error, invalidateCache };
}</code></pre>

                    <h4>创建防抖和节流Hook</h4>
                    <pre><code>// 防抖Hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    // 设置定时器
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    // 清除定时器
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // 仅在value或delay变化时重新执行
  
  return debouncedValue;
}

// 节流Hook
function useThrottle(value, delay) {
  const [throttledValue, setThrottledValue] = useState(value);
  const lastUpdate = useRef(Date.now());
  
  useEffect(() => {
    const handler = setTimeout(() => {
      const now = Date.now();
      if (now >= lastUpdate.current + delay) {
        setThrottledValue(value);
        lastUpdate.current = now;
      }
    }, delay - (Date.now() - lastUpdate.current));
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return throttledValue;
}

// 使用示例
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  // 使用防抖优化搜索
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  // 只有当防抖后的搜索词变化时才发送请求
  useEffect(() => {
    if (debouncedSearchTerm) {
      // 执行搜索
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);
  
  return (
    <input
      type="text"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}</code></pre>

                    <h3>4. 内存管理与泄漏预防 <span class="optimization-level level-advanced">高级</span></h3>
                    <p>内存泄漏可能导致应用性能下降，甚至崩溃。以下是一些防止内存泄漏的技巧：</p>

                    <h4>清理副作用</h4>
                    <p>在<code>useEffect</code>中返回清理函数，确保在组件卸载或重新渲染时清理副作用：</p>

                    <pre><code>function TimerComponent() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 设置定时器
    const timer = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);
    
    // 清理函数
    return () => {
      clearInterval(timer);
    };
  }, []);
  
  return <div>Count: {count}</div>;
}

// 清理事件监听器
function WindowSizeComponent() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    // 添加事件监听器
    window.addEventListener('resize', handleResize);
    
    // 清理事件监听器
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return (
    <div>
      <p>Width: {size.width}</p>
      <p>Height: {size.height}</p>
    </div>
  );
}</code></pre>

                    <h4>避免闭包陷阱</h4>
                    <p>在使用<code>useEffect</code>和<code>useState</code>时，要注意闭包陷阱：</p>

                    <div class="common-mistake">
                        <strong>闭包陷阱示例：</strong>
                        <pre><code>// 问题：handleClick总是引用的是初始的count值（0）
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 模拟延迟操作
    const timer = setTimeout(() => {
      console.log('Count is:', count);
    }, 3000);
    
    return () => clearTimeout(timer);
  }, []); // 空依赖数组
  
  const handleClick = () => {
    setCount(count + 1);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}</code></pre>
                    </div>

                    <p>解决方案：</p>
                    <pre><code>// 方案1：使用函数式更新
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      // 使用ref保存最新的count值
      console.log('Count is:', countRef.current);
    }, 3000);
    
    return () => clearTimeout(timer);
  }, []);
  
  // 使用ref保存最新值
  const countRef = useRef(count);
  useEffect(() => {
    countRef.current = count;
  }, [count]);
  
  const handleClick = () => {
    setCount(count + 1);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

// 方案2：在依赖数组中包含count
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      console.log('Count is:', count);
    }, 3000);
    
    return () => clearTimeout(timer);
  }, [count]); // 包含count在依赖数组中
  
  const handleClick = () => {
    setCount(count + 1);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}</code></pre>

                    <h3>5. 使用Web Workers进行后台计算 <span class="optimization-level level-advanced">高级</span></h3>
                    <p>对于CPU密集型任务，可以使用Web Workers在后台线程中执行，避免阻塞主线程。</p>

                    <h4>创建Web Worker</h4>
                    <p>首先创建一个Worker文件<code>calculation.worker.js</code>：</p>
                    <pre><code>// calculation.worker.js
// 监听来自主线程的消息
self.onmessage = function(e) {
  const { data } = e;
  
  // 执行复杂计算
  const result = performComplexCalculation(data);
  
  // 将结果发送回主线程
  self.postMessage({ result });
};

function performComplexCalculation(data) {
  // 这里是复杂的计算逻辑
  let result = 0;
  for (let i = 0; i < data.length; i++) {
    // 模拟耗时计算
    for (let j = 0; j < 100000; j++) {
      result += Math.sin(data[i]) * Math.cos(data[i]);
    }
  }
  return result;
}</code></pre>

                    <h4>在React组件中使用Worker</h4>
                    <pre><code>function DataProcessor() {
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(false);
  const workerRef = useRef(null);
  
  // 初始化Worker
  useEffect(() => {
    // 创建Worker实例
    workerRef.current = new Worker('/calculation.worker.js');
    
    // 监听Worker的消息
    workerRef.current.onmessage = (e) => {
      setResult(e.data.result);
      setLoading(false);
    };
    
    // 监听Worker错误
    workerRef.current.onerror = (error) => {
      console.error('Worker error:', error);
      setLoading(false);
    };
    
    // 组件卸载时终止Worker
    return () => {
      if (workerRef.current) {
        workerRef.current.terminate();
      }
    };
  }, []);
  
  // 开始计算
  const startCalculation = () => {
    setLoading(true);
    
    // 准备数据
    const data = Array.from({ length: 1000 }, (_, i) => i);
    
    // 发送数据到Worker
    workerRef.current.postMessage(data);
  };
  
  return (
    <div>
      <button onClick={startCalculation} disabled={loading}>
        {loading ? 'Calculating...' : 'Start Calculation'}
      </button>
      {result !== null && <div>Result: {result}</div>}
    </div>
  );
}</code></pre>

                    <h2>五、构建和部署优化</h2>

                    <h3>1. 生产环境优化 <span class="optimization-level level-basic">基础</span></h3>
                    <p>在构建生产环境应用时，确保启用了所有优化选项：</p>

                    <h4>使用正确的构建命令</h4>
                    <p>确保使用生产环境构建命令，如：</p>
                    <pre><code># Create React App
npm run build

# Next.js
npm run build

# Vite
npm run build</code></pre>

                    <h4>启用代码压缩和混淆</h4>
                    <p>现代构建工具（如Webpack、Vite等）默认在生产环境中启用代码压缩和混淆，但确保这些功能正常工作：</p>
                    <ul>
                        <li>JavaScript压缩（使用Terser）</li>
                        <li>CSS压缩（使用cssnano）</li>
                        <li>HTML压缩</li>
                        <li>Tree shaking（移除未使用的代码）</li>
                    </ul>

                    <h3>2. 资源优化 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>优化应用资源可以显著提高加载性能：</p>

                    <h4>图片优化</h4>
                    <ul>
                        <li>使用适当的图片格式（WebP、AVIF等）</li>
                        <li>实现响应式图片</li>
                        <li>使用图片压缩工具</li>
                        <li>实现懒加载</li>
                    </ul>

                    <h4>字体优化</h4>
                    <ul>
                        <li>使用字体子集化</li>
                        <li>预加载关键字体</li>
                        <li>使用适当的字体加载策略</li>
                    </ul>

                    <h3>3. 服务端渲染（SSR）和静态站点生成（SSG） <span class="optimization-level level-advanced">高级</span></h3>
                    <p>对于需要更好SEO和更快初始加载速度的应用，可以考虑使用服务端渲染（SSR）或静态站点生成（SSG）。</p>

                    <h4>使用Next.js实现SSR/SSG</h4>
                    <p>Next.js是一个流行的React框架，提供了开箱即用的SSR和SSG支持：</p>

                    <pre><code>// 服务端渲染页面（SSR）
export async function getServerSideProps() {
  // 在服务器上获取数据
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();
  
  // 将数据作为props传递给页面
  return {
    props: { data },
  };
}

function ServerRenderedPage({ data }) {
  return (
    <div>
      <h1>Server Rendered Page</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export default ServerRenderedPage;

// 静态站点生成页面（SSG）
export async function getStaticProps() {
  // 在构建时获取数据
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();
  
  // 将数据作为props传递给页面
  return {
    props: { data },
    // 重新生成页面的时间间隔（秒）
    revalidate: 10,
  };
}

function StaticPage({ data }) {
  return (
    <div>
      <h1>Static Page</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export default StaticPage;</code></pre>

                    <h3>4. 启用HTTP缓存 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>正确配置HTTP缓存可以减少重复资源的下载，提高应用性能：</p>

                    <h4>缓存策略建议</h4>
                    <ul>
                        <li><strong>静态资源（CSS、JavaScript、图片）：</strong>使用长期缓存（如1年）并配合内容哈希</li>
                        <li><strong>HTML页面：</strong>使用短期缓存或不缓存</li>
                        <li><strong>API响应：</strong>根据数据更新频率设置适当的缓存时间</li>
                    </ul>

                    <h4>示例Nginx配置</h4>
                    <pre><code>server {
    listen 80;
    server_name example.com;
    
    root /var/www/html;
    index index.html;
    
    # 静态资源缓存
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg)$ {
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
    }
    
    # HTML页面缓存
    location / {
        try_files $uri $uri/ /index.html;
        expires 1h;
        add_header Cache-Control "public, max-age=3600";
    }
}</code></pre>

                    <h2>六、性能监控与分析</h2>

                    <h3>1. 使用React DevTools Profiler <span class="optimization-level level-basic">基础</span></h3>
                    <p>React DevTools Profiler是分析React应用性能的强大工具：</p>

                    <ul>
                        <li><strong>录制交互：</strong>记录用户交互过程中的组件渲染情况</li>
                        <li><strong>火焰图：</strong>可视化组件渲染时间和调用栈</li>
                        <li><strong>排名视图：</strong>按渲染时间对组件进行排序</li>
                        <li><strong>提交视图：</strong>分析每次状态更新的渲染情况</li>
                    </ul>

                    <h3>2. 使用Performance API进行性能监控 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>使用浏览器的Performance API可以进行更精细的性能监控：</p>

                    <pre><code>// 标记性能测量点
performance.mark('start-operation');

// 执行操作
expensiveOperation();

// 结束性能测量
performance.mark('end-operation');

// 计算操作耗时
performance.measure('operation-duration', 'start-operation', 'end-operation');

// 获取测量结果
const measurements = performance.getEntriesByName('operation-duration');
console.log('Operation took:', measurements[0].duration, 'ms');

// 清理标记
performance.clearMarks('start-operation');
performance.clearMarks('end-operation');
performance.clearMeasures('operation-duration');</code></pre>

                    <h3>3. 实现用户体验指标监控 <span class="optimization-level level-intermediate">中级</span></h3>
                    <p>监控核心Web指标（Core Web Vitals）可以帮助我们了解用户的实际体验：</p>

                    <pre><code>// 监控LCP（Largest Contentful Paint）
new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();
  const lastEntry = entries[entries.length - 1];
  
  // LCP值应该小于2.5秒
  console.log('LCP:', lastEntry.startTime);
  
  // 可以将这个值发送到分析服务
  reportToAnalytics('lcp', lastEntry.startTime);
}).observe({type: 'largest-contentful-paint', buffered: true});

// 监控FID（First Input Delay）
new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();
  
  for (const entry of entries) {
    // FID值应该小于100毫秒
    console.log('FID:', entry.processingStart - entry.startTime);
    
    // 可以将这个值发送到分析服务
    reportToAnalytics('fid', entry.processingStart - entry.startTime);
  }
}).observe({type: 'first-input', buffered: true});

// 监控CLS（Cumulative Layout Shift）
let clsValue = 0;
let clsEntries = [];

new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();
  
  for (const entry of entries) {
    // 只考虑非用户交互触发的布局偏移
    if (!entry.hadRecentInput) {
      clsValue += entry.value;
      clsEntries.push(entry);
      
      // CLS值应该小于0.1
      console.log('Current CLS:', clsValue);
      
      // 可以将这个值发送到分析服务
      reportToAnalytics('cls', clsValue);
    }
  }
}).observe({type: 'layout-shift', buffered: true});</code></pre>

                    <h2>七、性能优化最佳实践总结</h2>

                    <p>以下是React应用性能优化的一些关键最佳实践：</p>

                    <h3>1. 组件优化</h3>
                    <ul>
                        <li>使用<code>React.memo</code>、<code>useMemo</code>和<code>useCallback</code>避免不必要的重新渲染</li>
                        <li>合理设计组件结构，避免组件过大或职责过多</li>
                        <li>为列表项提供稳定的key</li>
                        <li>避免在render中创建新对象或函数</li>
                    </ul>

                    <h3>2. 状态管理</h3>
                    <ul>
                        <li>合理拆分状态，避免状态过于集中</li>
                        <li>使用适当的状态管理方案（useState、useReducer、Context或外部库）</li>
                        <li>避免在高频更新的状态中包含大型数据</li>
                    </ul>

                    <h3>3. 数据加载与处理</h3>
                    <ul>
                        <li>实现数据缓存，避免重复请求</li>
                        <li>使用虚拟滚动处理大量数据</li>
                        <li>实现防抖和节流优化用户输入</li>
                        <li>使用Web Workers处理CPU密集型任务</li>
                    </ul>

                    <h3>4. 构建优化</h3>
                    <ul>
                        <li>启用代码分割和懒加载</li>
                        <li>优化静态资源（图片、字体、CSS等）</li>
                        <li>配置正确的HTTP缓存策略</li>
                        <li>考虑使用SSR或SSG提高初始加载性能</li>
                    </ul>

                    <h3>5. 监控与维护</h3>
                    <ul>
                        <li>使用React DevTools Profiler分析渲染性能</li>
                        <li>监控核心Web指标，了解用户真实体验</li>
                        <li>定期进行性能审计</li>
                        <li>注意内存管理，避免内存泄漏</li>
                    </ul>

                    <div class="performance-tip">
                        <strong>最终建议：</strong>性能优化是一个持续的过程，而不是一次性的任务。随着应用的发展和用户需求的变化，新的性能瓶颈可能会出现。建立良好的性能监控体系，并定期进行性能审计，是保持应用高性能的关键。
                    </div>

                    <p>通过应用这些优化技术，你可以显著提升React应用的性能，为用户提供更快、更流畅的体验。记住，性能优化的首要原则是"测量，然后优化"，避免盲目优化和过早优化。根据应用的具体需求和用户群体，选择最适合的优化策略。</p>
                </div>

                <!-- 文章标签 -->
                <div class="post-tags">
                    <a href="#" class="tag">React</a>
                    <a href="#" class="tag">性能优化</a>
                    <a href="#" class="tag">JavaScript</a>
                    <a href="#" class="tag">前端开发</a>
                </div>

                <!-- 文章导航 -->
                <div class="post-navigation">
                    <a href="progressive-web-app-guide.html" class="post-nav-link previous">
                        <span>渐进式Web应用（PWA）开发指南</span>
                        <i class="fas fa-arrow-left"></i>
                    </a>
                    <a href="css-animation-guide.html" class="post-nav-link next">
                        <i class="fas fa-arrow-right"></i>
                        <span>CSS动画与过渡效果实战指南</span>
                    </a>
                </div>
            </article>

            <!-- 相关文章 -->
            <div class="related-posts">
                <h3>相关文章</h3>
                <div class="related-posts-grid">
                    <div class="related-post">
                        <div class="related-post-image">
                            <img src="../images/blog1.svg" alt="前端性能优化">
                        </div>
                        <div class="related-post-content">
                            <div class="related-post-date">2023-07-08</div>
                            <h4 class="related-post-title"><a href="performance-optimization-guide.html">前端性能优化实战指南</a></h4>
                        </div>
                    </div>
                    <div class="related-post">
                        <div class="related-post-image">
                            <img src="../images/blog6.svg" alt="React Hooks">
                        </div>
                        <div class="related-post-content">
                            <div class="related-post-date">2023-05-20</div>
                            <h4 class="related-post-title"><a href="react-hooks-guide.html">React Hooks完全指南</a></h4>
                        </div>
                    </div>
                    <div class="related-post">
                        <div class="related-post-image">
                            <img src="../images/blog3.svg" alt="响应式设计">
                        </div>
                        <div class="related-post-content">
                            <div class="related-post-date">2023-03-12</div>
                            <h4 class="related-post-title"><a href="responsive-design-guide.html">响应式设计原则与实践</a></h4>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 评论区 -->
            <div class="comment-section">
                <h3>发表评论</h3>
                <form class="comment-form">
                    <div class="form-group">
                        <label for="comment-name">姓名</label>
                        <input type="text" id="comment-name" required>
                    </div>
                    <div class="form-group">
                        <label for="comment-email">邮箱</label>
                        <input type="email" id="comment-email" required>
                    </div>
                    <div class="form-group">
                        <label for="comment-content">评论内容</label>
                        <textarea id="comment-content" rows="5" required></textarea>
                    </div>
                    <button type="submit" class="btn btn-primary">提交评论</button>
                </form>
            </div>
        </div>
    </section>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-info">
                    <h3><i class="fas fa-leaf"></i> 个人博客</h3>
                    <p>探索技术与生活的交叉点</p>
                </div>
                <div class="footer-links">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../index.html">首页</a></li>
                        <li><a href="../index.html#about">关于我</a></li>
                        <li><a href="../index.html#blog">博客</a></li>
                        <li><a href="../index.html#contact">联系</a></li>
                    </ul>
                </div>
                <div class="footer-social">
                    <h4>关注我</h4>
                    <div class="social-links">
                        <a href="#" class="social-link"><i class="fab fa-github"></i></a>
                        <a href="#" class="social-link"><i class="fab fa-twitter"></i></a>
                        <a href="#" class="social-link"><i class="fab fa-linkedin"></i></a>
                        <a href="#" class="social-link"><i class="fab fa-weixin"></i></a>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2023 个人博客. 保留所有权利.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="back-to-top">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- 引入JavaScript -->
    <script src="../js/main.js"></script>
    <script>
        // 评论表单提交处理
        const commentForm = document.querySelector('.comment-form');
        if (commentForm) {
            commentForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                const submitButton = this.querySelector('button[type="submit"]');
                const originalText = submitButton.innerHTML;
                
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 提交中...';
                
                // 模拟评论提交
                setTimeout(() => {
                    submitButton.innerHTML = '<i class="fas fa-check"></i> 评论成功';
                    
                    // 重置表单
                    this.reset();
                    
                    // 恢复按钮状态
                    setTimeout(() => {
                        submitButton.disabled = false;
                        submitButton.innerHTML = originalText;
                    }, 2000);
                }, 1500);
            });
        }
    </script>
</body>
</html>